[
  {
    "id": "pos_0",
    "query_code": "def word_break(input_string: str, word_dict: set[str]) -> bool:\n    \"\"\"\n    Determines if the input string can be segmented into a sequence of\n    valid dictionary words using backtracking.\n\n    Parameters:\n    input_string (str): The input string to segment.\n    word_dict (set[str]): The set of valid words.\n\n    Returns:\n    bool: True if the string can be segmented into valid words, otherwise False.\n\n    Example:\n    >>> word_break(\"leetcode\", {\"leet\", \"code\"})\n    True\n\n    >>> word_break(\"applepenapple\", {\"apple\", \"pen\"})\n    True\n\n    >>> word_break(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"})\n    False\n    \"\"\"\n\n    return backtrack(input_string, word_dict, 0)",
    "original_id": "TheAlgorithms/Python::backtracking/word_break.py::word_break",
    "label": 1,
    "transformation": "variable_renaming"
  },
  {
    "id": "pos_1",
    "query_code": "def show_phase_response(filter_type: FilterType, samplerate: int) -> None:\n\n    size = 512\n    inputs = [1] + [0] * (size - 1)\n    outputs = [filter_type.process(item) for item in inputs]\n\n    filler = [0] * (samplerate - size)  \n    outputs += filler\n    fft_out = np.angle(np.fft.fft(outputs))\n\n    plt.xlim(24, samplerate / 2 - 1)\n    plt.xlabel(\"Frequency (Hz)\")\n    plt.xscale(\"log\")\n\n    plt.ylim(-2 * pi, 2 * pi)\n    plt.ylabel(\"Phase shift (Radians)\")\n    plt.plot(np.unwrap(fft_out, -2 * pi))\n    plt.show()",
    "original_id": "TheAlgorithms/Python::audio_filters/show_response.py::show_phase_response",
    "label": 1,
    "transformation": "comment_removal"
  },
  {
    "id": "neg_14",
    "query_code": "def parser():\n    \"\"\"\n    parser: parses the tokens of the list 'tokens'\n    \"\"\"\n\n    global tokens\n    global eax, ebx, ecx, edx\n\n    assert len(tokens) > 0, \"no tokens\"\n\n    pointer = 0  # pointer for tokens\n    token = Token(\"\", \"\")\n    tmpToken = Token(\"\", \"\")\n\n    while pointer < len(tokens):\n        token = tokens[pointer]\n\n        if token.token == \"mov\":  # mov commando\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found argument!\")\n                return\n\n            # TODO use token.t for this stuff\n            if token.t == \"register\":\n                tmpToken = token\n\n                # it must follow a value / string / register / variable\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    token = tokens[pointer]\n                else:\n                    print(\"Error: Not found argument!\")\n                    return\n\n                # converts the token into float, if token contains only digits.\n                # TODO response of float\n                if token.t == \"identifier\":  # for variables\n                    # check of exists of variable\n                    if token.token in variables:\n                        token.token = variables[token.token]\n                    else:\n                        print(f\"Error: Undefined variable {token.token}\")\n                        return\n\n                elif token.t == \"string\":\n                    token.token = str(token.token)\n\n                elif isinstance(token.token, float):\n                    pass\n                elif token.token.isdigit():\n                    token.token = float(token.token)\n                elif token.token[0] == \"-\" and token.token[1:].isdigit():\n                    token.token = float(token.token[1:])\n                    token.token *= -1\n                elif token.t == \"register\":  # loads out of register\n                    match token.token:\n                        case \"eax\":\n                            token.token = eax\n                        case \"ebx\":\n                            token.token = ebx\n                        case \"ecx\":\n                            token.token = ecx\n                        case \"edx\":\n                            token.token = edx\n\n                match tmpToken.token:\n                    case \"eax\":\n                        eax = token.token\n                    case \"ebx\":\n                        ebx = token.token\n                    case \"ecx\":\n                        ecx = token.token\n                    case \"edx\":\n                        edx = token.token\n\n            else:\n                print(\"Error: No found register!\")\n                return\n\n        elif token.token == \"add\":  # add commando\n            pointer += 1\n            token = tokens[pointer]\n\n            if token.t == \"register\":\n                tmpToken = token\n\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    token = tokens[pointer]\n                else:\n                    print(\"Error: Not found number!\")\n                    return\n\n                # converts the token into float, if token contains only digits.\n                if token.t == \"register\":\n                    # for the case that token is register\n                    match token.token:\n                        case \"eax\":\n                            token.token = eax\n                        case \"ebx\":\n                            token.token = ebx\n                        case \"ecx\":\n                            token.token = ecx\n                        case \"edx\":\n                            token.token = edx\n\n                elif token.token.isdigit():\n                    token.token = float(token.token)\n                elif token.token[0] == \"-\" and token.token[1:].isdigit():\n                    token.token = float(token.token[1:])\n                    token.token *= -1\n                else:\n                    print(\"Error: \", token, \" is not a number!\")\n                    return\n\n                match tmpToken.token:\n                    case \"eax\":\n                        eax += token.token\n\n                        # update zero flag\n                        zeroFlag = False\n                        if eax == 0:\n                            zeroFlag = True\n\n                    case \"ebx\":\n                        ebx += token.token\n\n                        # update zero flag\n                        zeroFlag = False\n                        if ebx == 0:\n                            zeroFlag = True\n\n                    case \"ecx\":\n                        ecx += token.token\n\n                        # update zero flag\n                        zeroFlag = False\n                        if ecx == 0:\n                            zeroFlag = True\n\n                    case \"edx\":\n                        edx += token.token\n\n                        # update zero flag\n                        zeroFlag = False\n                        if edx == 0:\n                            zeroFlag = True\n\n            else:\n                print(\"Error: Not found register!\")\n                return\n\n        elif token.token == \"sub\":  # sub commando\n            pointer += 1\n            token = tokens[pointer]\n\n            if token.t == \"register\":\n                tmpToken = token\n\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    token = tokens[pointer]\n                else:\n                    print(\"Error: Not found number!\")\n                    return\n\n                # converts the token into float, if token contains only digits.\n                if token.t == \"register\":\n                    # for the case that token is register\n                    if token.token == \"eax\":\n                        token.token = eax\n                    elif token.token == \"ebx\":\n                        token.token = ebx\n                    elif token.token == \"ecx\":\n                        token.token = ecx\n                    elif token.token == \"edx\":\n                        token.token = edx\n\n                elif isinstance(token.token, float):\n                    pass\n                elif token.token.isdigit():\n                    token.token = float(token.token)\n                elif token.token[0] == \"-\" and token.token[1:].isdigit():\n                    token.token = float(token.token[1:])\n                    token.token *= -1\n                else:\n                    print(\"Error: \", token.token, \" is not a number!\")\n                    return\n\n                if tmpToken.token == \"eax\":\n                    eax -= token.token\n\n                    # updated zero flag\n                    if eax == 0:\n                        zeroFlag = True\n                    else:\n                        zeroFlag = False\n                elif tmpToken.token == \"ebx\":\n                    ebx -= token.token\n\n                    # update zero flag\n                    if ebx == 0:\n                        zeroFlag = True\n                    else:\n                        zeroFlag = False\n                elif tmpToken.token == \"ecx\":\n                    ecx -= token.token\n\n                    # update zero flag\n                    if ecx == 0:\n                        zeroFlag = True\n                    else:\n                        zeroFlag = False\n                elif tmpToken.token == \"edx\":\n                    edx -= token.token\n\n                    # update zero flag\n                    if edx == 0:\n                        zeroFlag = True\n                    else:\n                        zeroFlag = False\n\n            else:\n                print(\"Error: No found register!\")\n                return\n\n        elif token.token == \"int\":  # int commando\n            tmpToken = token\n\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found argument!\")\n                return\n\n            if token.token == \"0x80\":  # system interrupt 0x80\n                if eax == 1:  # exit program\n                    if ebx == 0:\n                        print(\"END PROGRAM\")\n                        return\n                    else:\n                        print(\"END PROGRAM WITH ERRORS\")\n                        return\n\n                elif eax == 3:\n                    ecx = float(input(\">> \"))\n\n                elif eax == 4:  # output information\n                    print(ecx)\n\n        elif token.token == \"push\":  # push commando\n            tmpToken = token\n\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found register!\")\n                return\n\n            # pushing register on the stack\n            stack.append(token.token)\n\n        elif token.token == \"pop\":  # pop commando\n            tmpToken = token\n\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found register!\")\n                return\n\n            # pop register from stack\n            match token.token:\n                case \"eax\":\n                    if len(stack) == 0:\n                        print(\"Error: Stack Underflow\")\n                        return\n                    eax = stack.pop()\n                case \"ebx\":\n                    ebx = stack.pop()\n                case \"ecx\":\n                    ecx = stack.pop()\n                case \"edx\":\n                    edx = stack.pop()\n\n        elif token.t == \"label\":  # capture label\n            jumps[token.token] = pointer\n\n        elif token.token == \"jmp\":  # capture jmp command\n            # it must follow a label\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found label!\")\n                return\n\n            if token.t == \"label\":\n                pointer = jumps[token.token]\n\n            else:\n                print(\"Error: expected a label!\")\n\n        elif token.token == \"cmp\":\n            # TODO\n\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found argument!\")\n                return\n\n            if token.t == \"register\":\n                # it must follow a register\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    tmpToken = tokens[pointer]  # next register\n                else:\n                    print(\"Error: Not found register!\")\n                    return\n\n                # actual comparing\n                zeroFlag = setZeroFlag(token.token, tmpToken.token)\n\n        elif token.token == \"je\":\n            # it must follow a label\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]  # next register\n            else:\n                print(\"Error: Not found argument\")\n                return\n\n            # check of label\n            if token.t == \"label\":\n                # actual jump\n                if zeroFlag:\n                    pointer = jumps[token.token]\n\n            else:\n                print(\"Error: Not found label\")\n                return\n\n        elif token.t == \"identifier\":\n            # check whether identifier is in variables-table\n            if token.token not in variables:\n                # it must follow a command\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    tmpToken = tokens[pointer]  # next register\n                else:\n                    print(\"Error: Not found argument\")\n                    return\n\n                if tmpToken.t == \"command\" and tmpToken.token == \"db\":\n                    # it must follow a value (string)\n                    if pointer + 1 < len(tokens):\n                        pointer += 1\n                        tmpToken = tokens[pointer]  # next register\n                    else:\n                        print(\"Error: Not found argument\")\n                        return\n\n                    if tmpToken.t == \"value\" or tmpToken.t == \"string\":\n                        if tmpToken.t == \"value\":\n                            variables[token.token] = float(tmpToken.token)\n                        elif tmpToken.t == \"string\":\n                            variables[token.token] = tmpToken.token\n\n                else:\n                    print(\"Error: Not found db-keyword\")\n                    return\n\n        elif token.token == \"call\":  # catch the call-command\n            # it must follow a subprogram label\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]  # next register\n            else:\n                print(\"Error: Not found subprogram label\")\n                return\n\n            if token.t == \"subprogram\":\n                if token.token in jumps:\n                    # save the current pointer\n                    returnStack.append(pointer)  # eventuell pointer + 1\n                    # jump to the subprogram\n                    pointer = jumps[token.token]\n\n                else:  # error case\n                    print(\"Error: Unknown subprogram!\")\n                    return\n\n            else:  # error case\n                print(\"Error: Not found subprogram\")\n                return\n\n        elif token.token == \"ret\":  # catch the ret-command\n            if len(returnStack) >= 1:\n                pointer = returnStack.pop()\n\n            else:  # error case\n                print(\"Error: No return address on stack\")\n                return\n\n        elif token.t == \"subprogram\":\n            pass\n\n        elif token.token == \"mul\":  # catch mul-command\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]  # next register\n            else:\n                print(\"Error: Not found argument\")\n                return\n\n            if token.t == \"register\":\n                if token.token == \"eax\":\n                    eax *= eax\n\n                elif token.token == \"ebx\":\n                    eax *= ebx\n\n                elif token.token == \"ecx\":\n                    eax *= ecx\n\n                elif token.token == \"edx\":\n                    eax *= edx\n\n            else:\n                print(\"Error: Not found register\")\n                return\n\n        elif token.token == \"div\":\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]  # next register\n            else:\n                print(\"Error: Not found argument\")\n                return\n\n            if token.t == \"register\":\n                match token.token:\n                    case \"eax\":\n                        eax /= eax\n\n                    case \"ebx\":\n                        if ebx == 0:\n                            print(\"Error: Division by Zero\")\n                            return\n                        eax /= ebx\n\n                    case \"ecx\":\n                        eax /= ecx\n\n                    case \"edx\":\n                        eax /= edx\n\n            else:\n                print(\"Error: Not found register\")\n                return\n\n        # increment pointer for fetching next token.\n        pointer += 1",
    "original_id": "TheAlgorithms/Python::backtracking/generate_parentheses_iterative.py::generate_parentheses_iterative",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "pos_11",
    "query_code": "def create_all_state(\n    increment: int,\n    total_number: int,\n    level: int,\n    current_list: lst[int],\n    total_list: lst[lst[int]],\n) -> None:\n    if level == 0:\n        total_list.append(current_list[:])\n        return\n\n    for i in range(increment, total_number - level + 2):\n        current_list.append(i)\n        create_all_state(i + 1, total_number, level - 1, current_list, total_list)\n        current_list.pop()",
    "original_id": "TheAlgorithms/Python::backtracking/all_combinations.py::create_all_state",
    "label": 1,
    "transformation": "minor_refactoring"
  },
  {
    "id": "neg_7",
    "query_code": "def power_of_4(number: int) -> bool:\n    \"\"\"\n    Return True if this number is power of 4 or False otherwise.\n\n    >>> power_of_4(0)\n    Traceback (most recent call last):\n        ...\n    ValueError: number must be positive\n    >>> power_of_4(1)\n    True\n    >>> power_of_4(2)\n    False\n    >>> power_of_4(4)\n    True\n    >>> power_of_4(6)\n    False\n    >>> power_of_4(8)\n    False\n    >>> power_of_4(17)\n    False\n    >>> power_of_4(64)\n    True\n    >>> power_of_4(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: number must be positive\n    >>> power_of_4(1.2)\n    Traceback (most recent call last):\n        ...\n    TypeError: number must be an integer\n\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"number must be an integer\")\n    if number <= 0:\n        raise ValueError(\"number must be positive\")\n    if number & (number - 1) == 0:\n        c = 0\n        while number:\n            c += 1\n            number >>= 1\n        return c % 2 == 1\n    else:\n        return False",
    "original_id": "trekhleb/learn-python::src/functions/test_function_decorators.py::tags",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "neg_1",
    "query_code": "def provide_summarizer(Text):\n    # Set up Groq OpenAI-compatible API credentials\n    openai.api_key = os.getenv(\n        \"OPENAI_API_KEY\", \"your-api-key-here\"\n    )  # Replace or set in environment\n    openai.api_base = \"https://api.groq.com/openai/v1\"\n\n    # Extract text from the Whisper result\n    text_to_summarize = Text[\"text\"]\n\n    # Send the transcription to Groq for summarization\n    response = openai.ChatCompletion.create(\n        model=\"llama3-8b-8192\",\n        messages=[\n            {\n                \"role\": \"system\",\n                \"content\": \"You are a helpful assistant who summarizes long text into bullet points.\",\n            },\n            {\n                \"role\": \"user\",\n                \"content\": f\"Summarize the following:\\n\\n{text_to_summarize}\",\n            },\n        ],\n    )\n\n    # Split the response into sentences\n    summary = re.split(r\"(?<=[.!?]) +\", response[\"choices\"][0][\"message\"][\"content\"])\n\n    # Save summary to file\n    with open(\"summary.txt\", \"w+\", encoding=\"utf-8\") as file:\n        for sentence in summary:\n            cleaned = sentence.strip()\n            if cleaned:\n                file.write(\"- \" + cleaned + \"\\n\")",
    "original_id": "TheAlgorithms/Python::audio_filters/butterworth_filter.py::make_lowshelf",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "pos_12",
    "query_code": "def solve(needed_sum: int, power: int) -> int:\n    \"\"\"\n    >>> solve(13, 2)\n    1\n    >>> solve(10, 2)\n    1\n    >>> solve(10, 3)\n    0\n    >>> solve(20, 2)\n    1\n    >>> solve(15, 10)\n    0\n    >>> solve(16, 2)\n    1\n    >>> solve(20, 1)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    needed_sum must be between 1 and 1000, power between 2 and 10.\n    >>> solve(-10, 5)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid input\n    needed_sum must be between 1 and 1000, power between 2 and 10.\n    \"\"\"\n    if not (1 <= needed_sum <= 1000 and 2 <= power <= 10):\n        raise ValueError(\n            \"Invalid input\\n\"\n            \"needed_sum must be between 1 and 1000, power between 2 and 10.\"\n        )\n\n    return backtrack(needed_sum, power, 1, 0, 0)[1]  # Return the solutions_count",
    "original_id": "TheAlgorithms/Python::backtracking/power_sum.py::solve",
    "label": 1,
    "transformation": "variable_renaming"
  },
  {
    "id": "neg_4",
    "query_code": "def test_instance_objects():\n    \"\"\"Instance Objects.\n\n    Now what can we do with instance objects? The only operations understood by instance objects\n    are attribute references. There are two kinds of valid attribute names:\n    - data attributes\n    - methods.\n    \"\"\"\n\n    # DATA ATTRIBUTES need not be declared; like local variables, they spring into existence when\n    # they are first assigned to. For example, if x is the instance of MyCounter created above,\n    # the following piece of code will print the value 16, without leaving a trace.\n\n    # pylint: disable=too-few-public-methods\n    class DummyClass:\n        \"\"\"Dummy class\"\"\"\n        pass\n\n    dummy_instance = DummyClass()\n\n    # pylint: disable=attribute-defined-outside-init\n    dummy_instance.temporary_attribute = 1\n    assert dummy_instance.temporary_attribute == 1\n    del dummy_instance.temporary_attribute",
    "original_id": "TheAlgorithms/Python::bit_manipulation/find_previous_power_of_two.py::find_previous_power_of_two",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "pos_10",
    "query_code": "def create_state_space_tree(\n    sequence: list[int | str],\n    current_sequence: list[int | str],\n    index: int,\n    index_used: list[int],\n) -> None:\n\n    if index == len(sequence):\n        print(current_sequence)\n        return\n\n    for i in range(len(sequence)):\n        if not index_used[i]:\n            current_sequence.append(sequence[i])\n            index_used[i] = True\n            create_state_space_tree(sequence, current_sequence, index + 1, index_used)\n            current_sequence.pop()\n            index_used[i] = False",
    "original_id": "TheAlgorithms/Python::backtracking/all_permutations.py::create_state_space_tree",
    "label": 1,
    "transformation": "comment_removal"
  },
  {
    "id": "pos_14",
    "query_code": "def loadFile(fileName):\n    global lines\n\n    fo = open(fileName)\n\n    for line in fo:\n\n        lines.append(line)\n    fo.close()",
    "original_id": "geekcomputers/Python::Assembler/assembler.py::loadFile",
    "label": 1,
    "transformation": "minor_refactoring"
  },
  {
    "id": "pos_3",
    "query_code": "def resetInterpreter():\n    \"\"\"\n    resets the interpreter mind.\n    \"\"\"\n    global eax, ebx, ecx, edx, zeroFlag, stack\n    global variables, jumps, lines, tokens, returnStack\n    eax = 0\n    ebx = 0\n    ecx = 0\n    edx = 0\n    zeroFlag = False\n    stack = []\n    jumps = {}\n    variables = {}\n    lines = []\n    tokens = []\n    returnStack = []",
    "original_id": "geekcomputers/Python::Assembler/assembler.py::resetInterpreter",
    "label": 1,
    "transformation": "variable_renaming"
  },
  {
    "id": "pos_6",
    "query_code": "def sudoku(grid: Matrix) -> Matrix | None:\n    \"\"\"\n    Takes a partially filled-in grid and attempts to assign values to\n    all unassigned locations in such a way to meet the requirements\n    for Sudoku solution (non-duplication across rows, columns, and boxes)\n\n    >>> sudoku(initial_grid)  # doctest: +NORMALIZE_WHITESPACE\n    [[3, 1, 6, 5, 7, 8, 4, 9, 2],\n     [5, 2, 9, 1, 3, 4, 7, 6, 8],\n     [4, 8, 7, 6, 2, 9, 5, 3, 1],\n     [2, 6, 3, 4, 1, 5, 9, 8, 7],\n     [9, 7, 4, 8, 6, 3, 1, 2, 5],\n     [8, 5, 1, 7, 9, 2, 6, 4, 3],\n     [1, 3, 8, 9, 4, 7, 2, 5, 6],\n     [6, 9, 2, 3, 5, 1, 8, 7, 4],\n     [7, 4, 5, 2, 8, 6, 3, 1, 9]]\n     >>> sudoku(no_solution) is None\n     True\n    \"\"\"\n    if location := find_empty_location(grid):\n        row, column = location\n    else:\n        # If the location is ``None``, then the grid is solved.\n        return grid\n\n    for digit in range(1, 10):\n        if is_safe(grid, row, column, digit):\n            grid[row][column] = digit\n\n            if sudoku(grid) is not None:\n                return grid\n\n            grid[row][column] = 0\n\n    return None",
    "original_id": "TheAlgorithms/Python::backtracking/sudoku.py::sudoku",
    "label": 1,
    "transformation": "variable_renaming"
  },
  {
    "id": "pos_9",
    "query_code": "        def add_trick(self, trick):\n            \"\"\"Add trick to the dog\n\n            This function illustrate a correct use of mutable class variable tricks (see below).\n            \"\"\"\n            self.tricks.append(trick)",
    "original_id": "trekhleb/learn-python::src/classes/test_class_and_instance_variables.py::add_trick",
    "label": 1,
    "transformation": "variable_renaming"
  },
  {
    "id": "pos_13",
    "query_code": "    def __init__(\n        self,\n        board: List[List[int]],\n        goal: List[List[int]],\n        moves: int = 0,\n        previous: Optional[\"PuzzleState\"] = None,\n    ) -> None:\n        self.board = board  \n        self.goal = goal  \n        self.moves = moves  \n        self.previous = previous  ",
    "original_id": "geekcomputers/Python::8_puzzle.py::__init__",
    "label": 1,
    "transformation": "comment_removal"
  },
  {
    "id": "neg_12",
    "query_code": "    def do_global():\n        # Address the variable from very global scope and try to change it.\n        # pylint: disable=redefined-outer-name,global-statement\n        global test_variable\n        test_variable = 'global value'\n        return test_variable",
    "original_id": "TheAlgorithms/Python::audio_filters/butterworth_filter.py::make_lowpass",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "pos_8",
    "query_code": "def depth_first_search(\n    possible_board: lst[int],\n\n    diagonal_right_collisions: lst[int],\n    diagonal_left_collisions: lst[int],\n\n    boards: lst[lst[str]],\n    n: int,\n) -> None:\n\n    row = len(possible_board)\n\n    if row == n:\n        boards.append([\". \" * i + \"Q \" + \". \" * (n - 1 - i) for i in possible_board])\n        return\n\n\n    for col in range(n):\n        if (\n\n            col in possible_board\n            or row - col in diagonal_right_collisions\n            or row + col in diagonal_left_collisions\n        ):\n            continue\n\n        depth_first_search(\n            [*possible_board, col],\n            [*diagonal_right_collisions, row - col],\n\n            [*diagonal_left_collisions, row + col],\n            boards,\n            n,\n        )",
    "original_id": "TheAlgorithms/Python::backtracking/n_queens_math.py::depth_first_search",
    "label": 1,
    "transformation": "minor_refactoring"
  },
  {
    "id": "pos_5",
    "query_code": "def twos_complement(number: int) -> str:\n    if number > 0:\n        raise ValueError(\"input must be a negative integer\")\n    binary_number_length = len(bin(number)[3:])\n    twos_complement_number = bin(abs(number) - (1 << binary_number_length))[3:]\n    twos_complement_number = (\n        (\n            \"1\"\n            + \"0\" * (binary_number_length - len(twos_complement_number))\n            + twos_complement_number\n        )\n        if number < 0\n        else \"0\"\n    )\n\n    return \"0b\" + twos_complement_number",
    "original_id": "TheAlgorithms/Python::bit_manipulation/binary_twos_complement.py::twos_complement",
    "label": 1,
    "transformation": "minor_refactoring"
  },
  {
    "id": "neg_6",
    "query_code": "def convert_to_10(xnumber, xbase, arr, ybase):\n    if int(xbase) == 10:\n        for char in xnumber:\n            arr.append(char)\n        flipped = arr[::-1]\n        ans = 0\n        j = 0\n\n        for i in flipped:\n            ans = ans + (int(i) * (int(ybase) ** j))\n            j = j + 1\n        return ans",
    "original_id": "trekhleb/learn-python::src/functions/test_function_arbitrary_arguments.py::test_function_arbitrary_arguments",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "neg_9",
    "query_code": "    def tags(tag_name):\n        def tags_decorator(func):\n            def func_wrapper(name):\n                return \"<{0}>{1}</{0}>\".format(tag_name, func(name))\n            return func_wrapper\n        return tags_decorator",
    "original_id": "geekcomputers/Python::1 File handle/File handle text/counter.py::count",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "neg_5",
    "query_code": "def test_dictionary():\n    \"\"\"Dictionary\"\"\"\n\n    fruits_dictionary = {\n        'cherry': 'red',\n        'apple': 'green',\n        'banana': 'yellow',\n    }\n\n    assert isinstance(fruits_dictionary, dict)\n\n    # You may access set elements by keys.\n    assert fruits_dictionary['apple'] == 'green'\n    assert fruits_dictionary['banana'] == 'yellow'\n    assert fruits_dictionary['cherry'] == 'red'\n\n    # To check whether a single key is in the dictionary, use the in keyword.\n    assert 'apple' in fruits_dictionary\n    assert 'pineapple' not in fruits_dictionary\n\n    # Change the apple color to \"red\".\n    fruits_dictionary['apple'] = 'red'\n\n    # Add new key/value pair to the dictionary\n    fruits_dictionary['pineapple'] = 'yellow'\n    assert fruits_dictionary['pineapple'] == 'yellow'\n\n    # Performing list(d) on a dictionary returns a list of all the keys used in the dictionary,\n    # in insertion order (if you want it sorted, just use sorted(d) instead).\n    assert list(fruits_dictionary) == ['cherry', 'apple', 'banana', 'pineapple']\n    assert sorted(fruits_dictionary) == ['apple', 'banana', 'cherry', 'pineapple']\n\n    # It is also possible to delete a key:value pair with del.\n    del fruits_dictionary['pineapple']\n    assert list(fruits_dictionary) == ['cherry', 'apple', 'banana']\n\n    # The dict() constructor builds dictionaries directly from sequences of key-value pairs.\n    dictionary_via_constructor = dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n\n    assert dictionary_via_constructor['sape'] == 4139\n    assert dictionary_via_constructor['guido'] == 4127\n    assert dictionary_via_constructor['jack'] == 4098\n\n    # In addition, dict comprehensions can be used to create dictionaries from arbitrary key\n    # and value expressions:\n    dictionary_via_expression = {x: x**2 for x in (2, 4, 6)}\n    assert dictionary_via_expression[2] == 4\n    assert dictionary_via_expression[4] == 16\n    assert dictionary_via_expression[6] == 36\n\n    # When the keys are simple strings, it is sometimes easier to specify pairs using\n    # keyword arguments.\n    dictionary_for_string_keys = dict(sape=4139, guido=4127, jack=4098)\n    assert dictionary_for_string_keys['sape'] == 4139\n    assert dictionary_for_string_keys['guido'] == 4127\n    assert dictionary_for_string_keys['jack'] == 4098",
    "original_id": "TheAlgorithms/Python::audio_filters/butterworth_filter.py::make_highpass",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "pos_4",
    "query_code": "def solution(n: int = 600851475143) -> int:\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"Parameter n must be int or passive of cast to int.\")\n    if n <= 0:\n        raise ValueError(\"Parameter n must be greater or equal to one.\")\n\n    i = 2\n    ans = 0\n\n    if n == 2:\n        return 2\n\n    while n > 2:\n        while n % i != 0:\n            i += 1\n\n        ans = i\n\n        while n % i == 0:\n            n = n / i\n\n        i += 1\n\n    return int(ans)",
    "original_id": "geekcomputers/Python::A solution to project euler problem 3.py::solution",
    "label": 1,
    "transformation": "comment_removal"
  },
  {
    "id": "neg_2",
    "query_code": "def backtrack(\n    current_word: str, path: list[str], end_word: str, word_set: set[str]\n) -> list[str]:\n    \"\"\"\n    Helper function to perform backtracking to find the transformation\n    from the current_word to the end_word.\n\n    Parameters:\n    current_word (str): The current word in the transformation sequence.\n    path (list[str]): The list of transformations from begin_word to current_word.\n    end_word (str): The target word for transformation.\n    word_set (set[str]): The set of valid words for transformation.\n\n    Returns:\n    list[str]: The list of transformations from begin_word to end_word.\n               Returns an empty list if there is no valid\n                transformation from current_word to end_word.\n\n    Example:\n    >>> backtrack(\"hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"})\n    ['hit', 'hot', 'dot', 'lot', 'log', 'cog']\n\n    >>> backtrack(\"hit\", [\"hit\"], \"cog\", {\"hot\", \"dot\", \"dog\", \"lot\", \"log\"})\n    []\n\n    >>> backtrack(\"lead\", [\"lead\"], \"gold\", {\"load\", \"goad\", \"gold\", \"lead\", \"lord\"})\n    ['lead', 'lead', 'load', 'goad', 'gold']\n\n    >>> backtrack(\"game\", [\"game\"], \"code\", {\"came\", \"cage\", \"code\", \"cade\", \"gave\"})\n    ['game', 'came', 'cade', 'code']\n    \"\"\"\n\n    # Base case: If the current word is the end word, return the path\n    if current_word == end_word:\n        return path\n\n    # Try all possible single-letter transformations\n    for i in range(len(current_word)):\n        for c in string.ascii_lowercase:  # Try changing each letter\n            transformed_word = current_word[:i] + c + current_word[i + 1 :]\n            if transformed_word in word_set:\n                word_set.remove(transformed_word)\n                # Recur with the new word added to the path\n                result = backtrack(\n                    transformed_word, [*path, transformed_word], end_word, word_set\n                )\n                if result:  # valid transformation found\n                    return result\n                word_set.add(transformed_word)  # backtrack\n\n    return []  # No valid transformation found",
    "original_id": "trekhleb/learn-python::src/getting_started/test_variables.py::test_variables",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "neg_10",
    "query_code": "    def do_benchmark(number: int) -> None:\n        setup = \"import __main__ as z\"\n        print(f\"Benchmark when {number = }:\")\n        print(f\"{get_set_bits_count_using_modulo_operator(number) = }\")\n        timing = timeit(\n            f\"z.get_set_bits_count_using_modulo_operator({number})\", setup=setup\n        )\n        print(f\"timeit() runs in {timing} seconds\")\n        print(f\"{get_set_bits_count_using_brian_kernighans_algorithm(number) = }\")\n        timing = timeit(\n            f\"z.get_set_bits_count_using_brian_kernighans_algorithm({number})\",\n            setup=setup,\n        )\n        print(f\"timeit() runs in {timing} seconds\")",
    "original_id": "geekcomputers/Python::BrowserHistory/backend.py::visit",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "neg_0",
    "query_code": "        def add_trick(self, trick):\n            \"\"\"Add trick to the dog\n\n            This function illustrate a correct use of mutable class variable tricks (see below).\n            \"\"\"\n            self.tricks.append(trick)",
    "original_id": "TheAlgorithms/Python::backtracking/hamiltonian_cycle.py::hamilton_cycle",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "neg_8",
    "query_code": "def generate_sum_of_subsets_solutions(nums: list[int], max_sum: int) -> list[list[int]]:\n    \"\"\"\n    The main function. For list of numbers 'nums' find the subsets with sum\n    equal to 'max_sum'\n\n    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=9)\n    [[3, 4, 2], [4, 5]]\n    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=3)\n    [[3]]\n    >>> generate_sum_of_subsets_solutions(nums=[3, 34, 4, 12, 5, 2], max_sum=1)\n    []\n    \"\"\"\n\n    result: list[list[int]] = []\n    path: list[int] = []\n    num_index = 0\n    remaining_nums_sum = sum(nums)\n    create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)\n    return result",
    "original_id": "geekcomputers/Python::BlackJack_game/blackjack_simulate.py::insurance",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "neg_11",
    "query_code": "def gray_code(bit_count: int) -> list:\n    \"\"\"\n    Takes in an integer n and returns a n-bit\n    gray code sequence\n    An n-bit gray code sequence is a sequence of 2^n\n    integers where:\n\n    a) Every integer is between [0,2^n -1] inclusive\n    b) The sequence begins with 0\n    c) An integer appears at most one times in the sequence\n    d)The binary representation of every pair of integers differ\n       by exactly one bit\n    e) The binary representation of first and last bit also\n       differ by exactly one bit\n\n    >>> gray_code(2)\n    [0, 1, 3, 2]\n\n    >>> gray_code(1)\n    [0, 1]\n\n    >>> gray_code(3)\n    [0, 1, 3, 2, 6, 7, 5, 4]\n\n    >>> gray_code(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The given input must be positive\n\n    >>> gray_code(10.6)\n    Traceback (most recent call last):\n        ...\n    TypeError: unsupported operand type(s) for <<: 'int' and 'float'\n    \"\"\"\n\n    # bit count represents no. of bits in the gray code\n    if bit_count < 0:\n        raise ValueError(\"The given input must be positive\")\n\n    # get the generated string sequence\n    sequence = gray_code_sequence_string(bit_count)\n    #\n    # convert them to integers\n    for i in range(len(sequence)):\n        sequence[i] = int(sequence[i], 2)\n\n    return sequence",
    "original_id": "trekhleb/learn-python::src/modules/fibonacci_module.py::fibonacci_smaller_than",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "pos_2",
    "query_code": "def hit_or_stand(deck, hand):\n    global playing\n\n\n\n    while True:\n        x = input(\"Would you like to Hit or Stand? Enter '1' or '0' \")\n\n        if x.lower() == \"1\":\n            hit(deck, hand)\n\n\n        elif x.lower() == \"0\":\n            print(\"You chose to stand. Dealer will hit.\")\n            playing = False\n\n\n        else:\n            print(\"Wrong input, please try again.\")\n            continue\n\n        break\n",
    "original_id": "geekcomputers/Python::BlackJack_game/blackjack_rr.py::hit_or_stand",
    "label": 1,
    "transformation": "minor_refactoring"
  },
  {
    "id": "neg_3",
    "query_code": "def word_break(input_string: str, word_dict: set[str]) -> bool:\n    \"\"\"\n    Determines if the input string can be segmented into a sequence of\n    valid dictionary words using backtracking.\n\n    Parameters:\n    input_string (str): The input string to segment.\n    word_dict (set[str]): The set of valid words.\n\n    Returns:\n    bool: True if the string can be segmented into valid words, otherwise False.\n\n    Example:\n    >>> word_break(\"leetcode\", {\"leet\", \"code\"})\n    True\n\n    >>> word_break(\"applepenapple\", {\"apple\", \"pen\"})\n    True\n\n    >>> word_break(\"catsandog\", {\"cats\", \"dog\", \"sand\", \"and\", \"cat\"})\n    False\n    \"\"\"\n\n    return backtrack(input_string, word_dict, 0)",
    "original_id": "geekcomputers/Python::BlackJack_game/blackjack_simulate.py::bet_amount",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "neg_13",
    "query_code": "    def play(self):\n        while self.player.chips:\n            self.initial_game()\n            self.in_bet()\n            self.deal_card()\n            while self.go_on:\n                self.choice = self.menu()\n                # self.player.speak()\n                self.chips_manage()\n                try:\n                    self.card_manage()\n                except ValueError as res:\n                    self.bust = True\n                    self.go_on = False\n                    self.res = res\n            if not self.bust:\n                self.is_surrender()\n            self.winner = self.get_winner()\n            self.res = \"Winner is \" + self.winner\n            os.system(\"clear\")\n            self.calculate_chips()\n            self.result_exhibit()\n            self.dealer.unveiling()\n            self.player.unveiling()\n            self.recorder.record(\n                self.winner,\n                self.player.chips.amount,\n                self.player.point,\n                self.dealer.point,\n            )\n\n        self.recorder.draw_diagram()\n        ending = \"\\n\\tSorry I lost all chips!\\n\\tTime to say goodbye.\"\n        self.player.speak(ending)\n        print(\"\\n\" + \"-\" * 20 + \" End Game \" + \"-\" * 20)",
    "original_id": "trekhleb/learn-python::src/exceptions/test_handle_exceptions.py::test_handle_exceptions",
    "label": 0,
    "transformation": "none"
  },
  {
    "id": "pos_7",
    "query_code": "def test_arithmetic_operators():",
    "original_id": "trekhleb/learn-python::src/operators/test_arithmetic.py::test_arithmetic_operators",
    "label": 1,
    "transformation": "comment_removal"
  }
]